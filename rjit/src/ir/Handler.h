#ifndef HANDLER_H
#define HANDLER_H

#include "llvm.h"
#include "RIntlns.h"
#include "Intrinsics.h"
#include "JITModule.h"
#include "Tags.h"

namespace rjit {
namespace ir {

class Handler {
  public:
    typedef void handler;

    /** Each handler must know the module of code it operates on to allow
     * constant pool access code modifications.
     */
    Handler() {}

    /** The dispatcher method. Autogenerated in some other file.
     */
    virtual bool dispatch(llvm::BasicBlock::iterator& i) {
        defaultHandler(Instruction(i++));
        return true;
    }

    virtual void defaultHandler(Instruction ins) {
        std::cout << "default instruction handler" << std::endl;
    }
};

/** Predicates mockup

  Each predicate must have the match method, that takes the same arguments as
  the function they are guarding modulo all predicate arguments. It returns true
  if the predicate approves of the matching, false if it should be denied.

  The match method is deliberately not static - first we will still have to
  create the object and pass it, so no savings there, and second, while for
  simple cases we don't need the actual object, it might be beneficial as the
  predicate may pass further information to the handlers. In theory:)
 */

/** Base class for all predicates.
 */
class Predicate {};

class MockupPredicateA : public Predicate {
  public:
    bool match(Handler& h, GenericGetVar ins) {
        return ins.symbolValue() == Rf_install("a");
    }
};

class MockupPredicateB : public Predicate {
  public:
    bool match(Handler& h, GenericGetVar ins) {
        return ins.symbolValue() == Rf_install("b");
    }
};

namespace predicate {

template <typename T, typename W, typename... MATCH_SEQ>
class And {
  public:
    T lhs;
    W rhs;
    bool match(Handler& h, MATCH_SEQ... args) {
        return lhs.match(h, args...) and rhs.match(h, args...);
    }
};

template <typename T, typename W, typename... MATCH_SEQ>
class Or {
  public:
    T lhs;
    W rhs;
    bool match(Handler& h, MATCH_SEQ... args) {
        return lhs.match(h, args...) or rhs.match(h, args...);
    }
};
}

// Dummy Handler with empty implementation as a test case
class DummyHandler : public Handler {
  public:
    DummyHandler() : Handler() {}

    handler noRead(NoEnvAccess ins) {}

    handler gv(GenericGetVar ins) {
        getVar = true;
        read = true;
    }

    handler noWrite(NoEnvWrite ins) { read = true; }

    void defaultHandler(Instruction ins) override { write = true; }

  public:
    bool getVar = false;
    bool read = false;
    bool write = false;

    bool dispatch(llvm::BasicBlock::iterator& i) override;
};

class MyHandler : public Handler {
  public:
    MyHandler() : Handler() {}

    /** Handlers are identified by their return type handler - this is void
     * typedef that allows the codegen easily spot handlers.
     */
    handler genericGetVar(GenericGetVar ins, MockupPredicateA p) {
        std::cout << "GenericGetVar of A" << std::endl;
    }

    handler genericGetVar2x(GenericGetVar i1, GenericGetVar i2) {
        std::cout << "Two getvars!!!!" << std::endl;
    }

    handler genericGetVar(GenericGetVar ins, MockupPredicateB p) {
        std::cout << "GenericGetVar of B" << std::endl;
    }

    handler genericGetVar(GenericGetVar ins) {
        std::cout << "GenericGetVar" << std::endl;
    }

    handler genericAdd(GenericAdd ins) {
        std::cout << "GenericAdd" << std::endl;
    }

    handler ret(Return ins) { std::cout << "Return" << std::endl; }

    void defaultHandler(Instruction ins) override {
        std::cout << "HahaBaba" << std::endl;
    }

  public:
    bool dispatch(llvm::BasicBlock::iterator& i) override;
};

} // namespace ir
} // namespace rjit

#endif // HANDLER_H
