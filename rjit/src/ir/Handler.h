#ifndef HANDLER_H
#define HANDLER_H

#include "llvm.h"
#include "RIntlns.h"
#include "intrinsics.h"

namespace rjit {
namespace ir {

// this will identify the handler methods. I can in theory get them by their signature, but this is cleaner imho
#define handler protected


/** Predicates mockup

  Each predicate must have the match method, that takes the same arguments as the function they are guarding modulo all predicate arguments. It returns true if the predicate approves of the matching, false if it should be denied.

  The match method is deliberately not static - first we will still have to create the object and pass it, so no savings there, and second, while for simple cases we don't need the actual object, it might be beneficial as the predicate may pass further information to the handlers. In theory:)
 */
class MockupPredicateA {
public:
    bool match(GenericGetVar ins) {
        return ins.symbol() == Rf_install("a");
    }
};

class MockupPredicateB {
public:
    bool match(GenericGetVar ins) {
        return ins.symbol() == Rf_install("b");
    }
};


class Handler {

public:
    /** The dispatcher method. Autogenerated in some other file.
     */
    virtual void dispatch(llvm::Instruction * ins, Type type) {
        defaultHandler(Instruction(ins));
    }

    virtual void defaultHandler(Instruction ins) {
        std::cout << "default instruction handler" << std::endl;
    }

};


class MyHandler: public Handler {



handler:
    void genericGetVar(GenericGetVar ins, MockupPredicateA p) {
        std::cout << "GenericGetVar of A" << std::endl;
    }

    void genericGetVar(GenericGetVar ins, MockupPredicateB p) {
        std::cout << "GenericGetVar of B" << std::endl;
    }

    void genericGetVar(GenericGetVar ins) {
        std::cout << "GenericGetVar" << std::endl;
    }

    void genericAdd(GenericAdd ins) {
        std::cout << "GenericAdd" << std::endl;
    }

    void ret(Return ins) {
        std::cout << "Return" << std::endl;
    }

    void defaultHandler(Instruction ins) override {
        std::cout << "HahaBaba" << std::endl;
    }
public:
    void dispatch(llvm::Instruction * ins, Type type) override {
        switch (type) {
        case Type::GenericAdd:
            genericAdd(GenericAdd(ins));
            break;
        case Type::GenericGetVar:
            MockupPredicateA pa;
            MockupPredicateB pb;
            if (pa.match(ins))
                genericGetVar(ins, pa);
            else if (pb.match(ins))
                genericGetVar(ins, pb);
            else
                genericGetVar(GenericGetVar(ins));
            break;
        case Type::ret:
            ret(Return(ins));
            break;
        default:
            Handler::dispatch(ins, type);
        }
    }



};

} // namespace ir
} // namespace rjit

#endif // HANDLER_H

