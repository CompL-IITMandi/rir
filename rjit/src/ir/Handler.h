#ifndef HANDLER_H
#define HANDLER_H

#include "llvm.h"
#include "RIntlns.h"
#include "intrinsics.h"

namespace rjit {
namespace ir {

/** Predicates mockup

  Each predicate must have the match method, that takes the same arguments as the function they are guarding modulo all predicate arguments. It returns true if the predicate approves of the matching, false if it should be denied.

  The match method is deliberately not static - first we will still have to create the object and pass it, so no savings there, and second, while for simple cases we don't need the actual object, it might be beneficial as the predicate may pass further information to the handlers. In theory:)
 */

/** Base class for all predicates.
 */
class Predicate {
};

class MockupPredicateA: public Predicate {
public:
    bool match(GenericGetVar_ ins) {
        return true;
        //return ins.symbol() == Rf_install("a");
    }
};

class MockupPredicateB : public Predicate {
public:
    bool match(GenericGetVar_ ins) {
        return true;
        //return ins.symbol() == Rf_install("b");
    }
};

namespace predicate {

template<typename T, typename W, typename... MATCH_SEQ>
class And {
public:
    T lhs;
    W rhs;
    bool match(MATCH_SEQ... args) {
        return lhs.match(args...) and rhs.match(args...);
    }
};

template<typename T, typename W, typename... MATCH_SEQ>
class Or {
public:
    T lhs;
    W rhs;
    bool match(MATCH_SEQ... args) {
        return lhs.match(args...) or rhs.match(args...);
    }
};


}




class Handler {
public:
    typedef void handler;

    /** The dispatcher method. Autogenerated in some other file.
     */
    virtual bool dispatch(llvm::BasicBlock::iterator & i) {
        defaultHandler(Instruction(i++));
        return true;
    }

    virtual handler defaultHandler(Instruction ins) {
        std::cout << "default instruction handler" << std::endl;
    }

    void x() {

    }

};


class MyHandler: public Handler {



public:

    void x() {

    }

    /** Handlers are identified by their return type handler - this is void typedef that allows the codegen easily spot handlers.
     */
    handler genericGetVar(GenericGetVar_ ins, MockupPredicateA p) {
        std::cout << "GenericGetVar of A" << std::endl;
    }

    handler genericGetVar2x(GenericGetVar_ i1, GenericGetVar_ i2) {
        std::cout << "Two getvars!!!!" << std::endl;
    }

    handler genericGetVar(GenericGetVar_ ins, MockupPredicateB p) {
        std::cout << "GenericGetVar of B" << std::endl;
    }

    handler genericGetVar(GenericGetVar_ ins) {
        std::cout << "GenericGetVar" << std::endl;
    }

    handler genericAdd(GenericAdd_ ins) {
        std::cout << "GenericAdd" << std::endl;
    }

    handler ret(Return ins) {
        std::cout << "Return" << std::endl;
    }

    handler defaultHandler(Instruction ins) override {
        std::cout << "HahaBaba" << std::endl;
    }
public:

    bool dispatch(llvm::BasicBlock::iterator & i) override;


};

} // namespace ir
} // namespace rjit

#endif // HANDLER_H

