#ifndef HANDLER_H
#define HANDLER_H

#include "llvm.h"
#include "RIntlns.h"
#include "intrinsics.h"

namespace rjit {
namespace ir {

/** Predicates mockup

  Each predicate must have the match method, that takes the same arguments as the function they are guarding modulo all predicate arguments. It returns true if the predicate approves of the matching, false if it should be denied.

  The match method is deliberately not static - first we will still have to create the object and pass it, so no savings there, and second, while for simple cases we don't need the actual object, it might be beneficial as the predicate may pass further information to the handlers. In theory:)
 */

/** Base class for all predicates.
 */
class Predicate {

};

class MockupPredicateA: public Predicate {
public:
    bool match(GenericGetVar ins) {
        return ins.symbol() == Rf_install("a");
    }
};

class MockupPredicateB : public Predicate {
public:
    bool match(GenericGetVar ins) {
        return ins.symbol() == Rf_install("b");
    }
};

namespace predicate {

template<typename T, typename W, typename... MATCH_SEQ>
class And {
public:
    T lhs;
    W rhs;
    bool match(MATCH_SEQ... args) {
        return lhs.match(args...) and rhs.match(args...);
    }
};

template<typename T, typename W, typename... MATCH_SEQ>
class Or {
public:
    T lhs;
    W rhs;
    bool match(MATCH_SEQ... args) {
        return lhs.match(args...) or rhs.match(args...);
    }
};


}




class Handler {
public:
    typedef void handler;

    /** The dispatcher method. Autogenerated in some other file.
     */
    virtual bool dispatch(llvm::BasicBlock::iterator & i) {
        defaultHandler(Instruction(i++));
        return true;
    }

    virtual handler defaultHandler(Instruction ins) {
        std::cout << "default instruction handler" << std::endl;
    }

    void x() {

    }

};


class MyHandler: public Handler {



public:

    void x() {

    }

    /** Handlers are identified by their return type handler - this is void typedef that allows the codegen easily spot handlers.
     */
    handler genericGetVar(GenericGetVar ins, MockupPredicateA p) {
        std::cout << "GenericGetVar of A" << std::endl;
    }

    handler genericGetVar2x(GenericGetVar i1, GenericGetVar i2) {
        std::cout << "Two getvars!!!!" << std::endl;
    }

    handler genericGetVar(GenericGetVar ins, MockupPredicateB p) {
        std::cout << "GenericGetVar of B" << std::endl;
    }

    handler genericGetVar(GenericGetVar ins) {
        std::cout << "GenericGetVar" << std::endl;
    }

    handler genericAdd(GenericAdd ins) {
        std::cout << "GenericAdd" << std::endl;
    }

    handler ret(Return ins) {
        std::cout << "Return" << std::endl;
    }

    handler defaultHandler(Instruction ins) override {
        std::cout << "HahaBaba" << std::endl;
    }
public:
    /*
    void dispatch(llvm::Instruction * ins, Type type) override {
        switch (type) {
        case Type::GenericAdd:
            genericAdd(GenericAdd(ins));
            break;
        case Type::GenericGetVar:
            MockupPredicateA pa;
            MockupPredicateB pb;
            if (pa.match(ins))
                genericGetVar(ins, pa);
            else if (pb.match(ins))
                genericGetVar(ins, pb);
            else
                genericGetVar(GenericGetVar(ins));
            break;
        case Type::Return:
            ret(Return(ins));
            break;
        default:
            Handler::dispatch(ins, type);
        }
    } */


    /** returns true if matched, false otherwise.
     */
   /* bool dispatch(llvm::BasicBlock::iterator & i) override {
        llvm::BasicBlock::iterator j = i;
        Type t = Instruction::match(j);
        switch (t) {
        case Type::GenericGetVar: {
            // recursion when matching sequence
            if (! i->isTerminator()) {
                llvm::BasicBlock::iterator k = j;
                Type t2 = Instruction::match(k);
                switch (t2) {
                case Type::GenericGetVar:
                    genericGetVar2x(GenericGetVar(i), GenericGetVar(j));
                    i = k;
                    return true;
                }
            }
            // now the normal matching continues
            MockupPredicateA pa;
            MockupPredicateB pb;
            if (pa.match(&*i))
                genericGetVar(&*i, pa);
            else if (pb.match(&*i))
                genericGetVar(&*i, pb);
            else
                genericGetVar(&*i);
            i = j;
            return true;
        }
        case Type::GenericAdd: {
            genericAdd(&*i);
            i = j;
            return true;
        }
        case Type::Return: {
            ret(&*i);
            i = j;
            break;
        }
        default:
            Handler::dispatch(i);
       }
    } */
#pragma GCC diagnostic ignored "-Wall"
bool dispatch(llvm::BasicBlock::iterator & i) {
    llvm::BasicBlock::iterator ii = i;
    rjit::ir::Type t = rjit::ir::Instruction::match(ii);
    switch (t) {
    case rjit::ir::Type::GenericAdd: {
        genericAdd(&*i);
        i = ii;
        return true;
    }
    case rjit::ir::Type::GenericGetVar: {
        if (not i->isTerminator()) {
            llvm::BasicBlock::iterator iii = ii;
            rjit::ir::Type t = rjit::ir::Instruction::match(iii);
            switch (t) {
            case rjit::ir::Type::GenericGetVar: {
                genericGetVar2x(&*i, &*ii);
                i = iii;
                return true;
            }
            }
        }
        {
            rjit::ir::MockupPredicateA p;
            if (p.match(&*i)) {
                genericGetVar(&*i);
                return true;
            }
        }
        {
            rjit::ir::MockupPredicateB p;
            if (p.match(&*i)) {
                genericGetVar(&*i);
                return true;
            }
        }
        genericGetVar(&*i);
        i = ii;
        return true;
    }
    case rjit::ir::Type::Return: {
        ret(&*i);
        i = ii;
        return true;
    }
    }
    if (rjit::ir::Handler::dispatch(i))
        return true;

    return false;
}


};

} // namespace ir
} // namespace rjit

#endif // HANDLER_H

