/*
AUTOMATICALLY GENERATED FILE, DO NOT EDIT. 

This file is automatically generated as part of the rjit build step. Do not edit it directly as all your changes will be lost after a new build cycle. If you want to change which intrinsics are supported, edit the respective files that define them. 
*/

#ifndef INTRINSICS_H_
#define INTRINSICS_H_

#include "ir.h"
#include "Builder.h"

namespace rjit {
namespace ir {

/** Replacement for GETSTACK_LOGICAL_NO_NA_PTR
The call is used only for error reporting.
*/
class convertToLogicalNoNA: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * what() { return getValue(0); }
    SEXP call() { return getValueSEXP(1); }
    convertToLogicalNoNA(llvm::CallInst * ins): Intrinsic(ins) {}
    static convertToLogicalNoNA create(Builder & b, llvm::Value * what, SEXP call) {
        std::vector<llvm::Value *> args_;
        args_.push_back(what);
        args_.push_back(Builder::constantPoolSexp(call));
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class printValue: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * value() { return getValue(0); }
    printValue(llvm::CallInst * ins): Intrinsic(ins) {}
    static printValue create(Builder & b, llvm::Value * value) {
        std::vector<llvm::Value *> args_;
        args_.push_back(value);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};
/** startFor returns the sequence over which the loop will iterate.
No need for all the other things here because we do not support other than generic variable loads and stores.
*/
class startFor: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * seq() { return getValue(0); }
    llvm::Value * rho() { return getValue(1); }
    startFor(llvm::CallInst * ins): Intrinsic(ins) {}
    static startFor create(Builder & b, llvm::Value * seq, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(seq);
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};
/** Loop sequence length returns the length of the sequence the loop will iterate over and errors if the sequence is of wrong type.
*/
class loopSequenceLength: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * seq() { return getValue(0); }
    SEXP call() { return getValueSEXP(1); }
    loopSequenceLength(llvm::CallInst * ins): Intrinsic(ins) {}
    static loopSequenceLength create(Builder & b, llvm::Value * seq, SEXP call) {
        std::vector<llvm::Value *> args_;
        args_.push_back(seq);
        args_.push_back(Builder::constantPoolSexp(call));
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};
/** Given the for loop sequence, and index, returns the index-th value of the sequence.
TODO Note that this always allocates for vectors.
*/
class getForLoopValue: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * seq() { return getValue(0); }
    int index() { return getValueInt(1); }
    getForLoopValue(llvm::CallInst * ins): Intrinsic(ins) {}
    static getForLoopValue create(Builder & b, llvm::Value * seq, int index) {
        std::vector<llvm::Value *> args_;
        args_.push_back(seq);
        args_.push_back(Builder::integer(index));
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class markVisible: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    markVisible(llvm::CallInst * ins): Intrinsic(ins) {}
    static markVisible create(Builder & b) {
        std::vector<llvm::Value *> args_;
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class markInvisible: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    markInvisible(llvm::CallInst * ins): Intrinsic(ins) {}
    static markInvisible create(Builder & b) {
        std::vector<llvm::Value *> args_;
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};
/** When LLVM IR creates user visible constant, this function contains all the code required to make the constant.
Currently this means marking it as not mutable only.
*/
class userConstant: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * value() { return getValue(0); }
    userConstant(llvm::CallInst * ins): Intrinsic(ins) {}
    static userConstant create(Builder & b, llvm::Value * value) {
        std::vector<llvm::Value *> args_;
        args_.push_back(value);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};
/** Generic getvar does not use any caches whatsoever.
TODO this means we can get rid of the checks in getvar(), and reduce its code to this. We definitely want faster versions.
*/
class genericGetVar: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    SEXP symbol() { return getValueSEXP(0); }
    llvm::Value * rho() { return getValue(1); }
    genericGetVar(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericGetVar create(Builder & b, SEXP symbol, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(Builder::constantPoolSexp(symbol));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericGetEllipsisArg: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    SEXP symbol() { return getValueSEXP(0); }
    llvm::Value * rho() { return getValue(1); }
    genericGetEllipsisArg(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericGetEllipsisArg create(Builder & b, SEXP symbol, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(Builder::constantPoolSexp(symbol));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericSetVar: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    SEXP symbol() { return getValueSEXP(0); }
    llvm::Value * value() { return getValue(1); }
    llvm::Value * rho() { return getValue(2); }
    genericSetVar(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericSetVar create(Builder & b, SEXP symbol, llvm::Value * value, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(Builder::constantPoolSexp(symbol));
        args_.push_back(value);
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericSetVarParent: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    SEXP symbol() { return getValueSEXP(0); }
    llvm::Value * value() { return getValue(1); }
    llvm::Value * rho() { return getValue(2); }
    genericSetVarParent(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericSetVarParent create(Builder & b, SEXP symbol, llvm::Value * value, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(Builder::constantPoolSexp(symbol));
        args_.push_back(value);
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class getFunction: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    SEXP symbol() { return getValueSEXP(0); }
    llvm::Value * rho() { return getValue(1); }
    getFunction(llvm::CallInst * ins): Intrinsic(ins) {}
    static getFunction create(Builder & b, SEXP symbol, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(Builder::constantPoolSexp(symbol));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class getGlobalFunction: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    SEXP symbol() { return getValueSEXP(0); }
    getGlobalFunction(llvm::CallInst * ins): Intrinsic(ins) {}
    static getGlobalFunction create(Builder & b, SEXP symbol) {
        std::vector<llvm::Value *> args_;
        args_.push_back(Builder::constantPoolSexp(symbol));
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class getSymFunction: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    SEXP name() { return getValueSEXP(0); }
    getSymFunction(llvm::CallInst * ins): Intrinsic(ins) {}
    static getSymFunction create(Builder & b, SEXP name) {
        std::vector<llvm::Value *> args_;
        args_.push_back(Builder::constantPoolSexp(name));
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class getBuiltinFunction: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    SEXP name() { return getValueSEXP(0); }
    getBuiltinFunction(llvm::CallInst * ins): Intrinsic(ins) {}
    static getBuiltinFunction create(Builder & b, SEXP name) {
        std::vector<llvm::Value *> args_;
        args_.push_back(Builder::constantPoolSexp(name));
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class getInternalBuiltinFunction: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    SEXP name() { return getValueSEXP(0); }
    getInternalBuiltinFunction(llvm::CallInst * ins): Intrinsic(ins) {}
    static getInternalBuiltinFunction create(Builder & b, SEXP name) {
        std::vector<llvm::Value *> args_;
        args_.push_back(Builder::constantPoolSexp(name));
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class checkFunction: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * f() { return getValue(0); }
    checkFunction(llvm::CallInst * ins): Intrinsic(ins) {}
    static checkFunction create(Builder & b, llvm::Value * f) {
        std::vector<llvm::Value *> args_;
        args_.push_back(f);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};
/** Creates a promise out of the given code and environment and returns its value.
*/
class createPromise: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    SEXP code() { return getValueSEXP(0); }
    llvm::Value * rho() { return getValue(1); }
    createPromise(llvm::CallInst * ins): Intrinsic(ins) {}
    static createPromise create(Builder & b, SEXP code, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(Builder::constantPoolSexp(code));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};
/** Given a SEXP, returns its type.
We can perfectly do this in LLVM, but having an function for it simplifies the analysis on our end.
*/
class sexpType: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * value() { return getValue(0); }
    sexpType(llvm::CallInst * ins): Intrinsic(ins) {}
    static sexpType create(Builder & b, llvm::Value * value) {
        std::vector<llvm::Value *> args_;
        args_.push_back(value);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class addArgument: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * args() { return getValue(0); }
    llvm::Value * arg() { return getValue(1); }
    addArgument(llvm::CallInst * ins): Intrinsic(ins) {}
    static addArgument create(Builder & b, llvm::Value * args, llvm::Value * arg) {
        std::vector<llvm::Value *> args_;
        args_.push_back(args);
        args_.push_back(arg);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class addKeywordArgument: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * args() { return getValue(0); }
    llvm::Value * arg() { return getValue(1); }
    llvm::Value * name() { return getValue(2); }
    addKeywordArgument(llvm::CallInst * ins): Intrinsic(ins) {}
    static addKeywordArgument create(Builder & b, llvm::Value * args, llvm::Value * arg, llvm::Value * name) {
        std::vector<llvm::Value *> args_;
        args_.push_back(args);
        args_.push_back(arg);
        args_.push_back(name);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class addEllipsisArgument: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * args() { return getValue(0); }
    llvm::Value * rho() { return getValue(1); }
    llvm::Value * eager() { return getValue(2); }
    addEllipsisArgument(llvm::CallInst * ins): Intrinsic(ins) {}
    static addEllipsisArgument create(Builder & b, llvm::Value * args, llvm::Value * rho, llvm::Value * eager) {
        std::vector<llvm::Value *> args_;
        args_.push_back(args);
        args_.push_back(rho);
        args_.push_back(eager);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class callBuiltin: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * call() { return getValue(0); }
    llvm::Value * closure() { return getValue(1); }
    llvm::Value * arguments() { return getValue(2); }
    llvm::Value * rho() { return getValue(3); }
    callBuiltin(llvm::CallInst * ins): Intrinsic(ins) {}
    static callBuiltin create(Builder & b, llvm::Value * call, llvm::Value * closure, llvm::Value * arguments, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(call);
        args_.push_back(closure);
        args_.push_back(arguments);
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class callSpecial: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * call() { return getValue(0); }
    llvm::Value * closure() { return getValue(1); }
    llvm::Value * arguments() { return getValue(2); }
    llvm::Value * rho() { return getValue(3); }
    callSpecial(llvm::CallInst * ins): Intrinsic(ins) {}
    static callSpecial create(Builder & b, llvm::Value * call, llvm::Value * closure, llvm::Value * arguments, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(call);
        args_.push_back(closure);
        args_.push_back(arguments);
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class callClosure: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * call() { return getValue(0); }
    llvm::Value * closure() { return getValue(1); }
    llvm::Value * arguments() { return getValue(2); }
    llvm::Value * rho() { return getValue(3); }
    callClosure(llvm::CallInst * ins): Intrinsic(ins) {}
    static callClosure create(Builder & b, llvm::Value * call, llvm::Value * closure, llvm::Value * arguments, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(call);
        args_.push_back(closure);
        args_.push_back(arguments);
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class createClosure: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * forms() { return getValue(0); }
    llvm::Value * body() { return getValue(1); }
    llvm::Value * rho() { return getValue(2); }
    createClosure(llvm::CallInst * ins): Intrinsic(ins) {}
    static createClosure create(Builder & b, llvm::Value * forms, llvm::Value * body, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(forms);
        args_.push_back(body);
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericUnaryMinus: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * op() { return getValue(0); }
    SEXP call() { return getValueSEXP(1); }
    llvm::Value * rho() { return getValue(2); }
    genericUnaryMinus(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericUnaryMinus create(Builder & b, llvm::Value * op, SEXP call, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(op);
        args_.push_back(Builder::constantPoolSexp(call));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericUnaryPlus: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * op() { return getValue(0); }
    SEXP call() { return getValueSEXP(1); }
    llvm::Value * rho() { return getValue(2); }
    genericUnaryPlus(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericUnaryPlus create(Builder & b, llvm::Value * op, SEXP call, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(op);
        args_.push_back(Builder::constantPoolSexp(call));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericAdd: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * lhs() { return getValue(0); }
    llvm::Value * rhs() { return getValue(1); }
    SEXP call() { return getValueSEXP(2); }
    llvm::Value * rho() { return getValue(3); }
    genericAdd(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericAdd create(Builder & b, llvm::Value * lhs, llvm::Value * rhs, SEXP call, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(lhs);
        args_.push_back(rhs);
        args_.push_back(Builder::constantPoolSexp(call));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericSub: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * lhs() { return getValue(0); }
    llvm::Value * rhs() { return getValue(1); }
    SEXP call() { return getValueSEXP(2); }
    llvm::Value * rho() { return getValue(3); }
    genericSub(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericSub create(Builder & b, llvm::Value * lhs, llvm::Value * rhs, SEXP call, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(lhs);
        args_.push_back(rhs);
        args_.push_back(Builder::constantPoolSexp(call));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericMul: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * lhs() { return getValue(0); }
    llvm::Value * rhs() { return getValue(1); }
    SEXP call() { return getValueSEXP(2); }
    llvm::Value * rho() { return getValue(3); }
    genericMul(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericMul create(Builder & b, llvm::Value * lhs, llvm::Value * rhs, SEXP call, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(lhs);
        args_.push_back(rhs);
        args_.push_back(Builder::constantPoolSexp(call));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericDiv: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * lhs() { return getValue(0); }
    llvm::Value * rhs() { return getValue(1); }
    SEXP call() { return getValueSEXP(2); }
    llvm::Value * rho() { return getValue(3); }
    genericDiv(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericDiv create(Builder & b, llvm::Value * lhs, llvm::Value * rhs, SEXP call, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(lhs);
        args_.push_back(rhs);
        args_.push_back(Builder::constantPoolSexp(call));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericPow: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * lhs() { return getValue(0); }
    llvm::Value * rhs() { return getValue(1); }
    SEXP call() { return getValueSEXP(2); }
    llvm::Value * rho() { return getValue(3); }
    genericPow(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericPow create(Builder & b, llvm::Value * lhs, llvm::Value * rhs, SEXP call, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(lhs);
        args_.push_back(rhs);
        args_.push_back(Builder::constantPoolSexp(call));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericSqrt: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * op() { return getValue(0); }
    SEXP call() { return getValueSEXP(1); }
    llvm::Value * rho() { return getValue(2); }
    genericSqrt(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericSqrt create(Builder & b, llvm::Value * op, SEXP call, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(op);
        args_.push_back(Builder::constantPoolSexp(call));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericExp: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * op() { return getValue(0); }
    SEXP call() { return getValueSEXP(1); }
    llvm::Value * rho() { return getValue(2); }
    genericExp(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericExp create(Builder & b, llvm::Value * op, SEXP call, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(op);
        args_.push_back(Builder::constantPoolSexp(call));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericEq: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * lhs() { return getValue(0); }
    llvm::Value * rhs() { return getValue(1); }
    SEXP call() { return getValueSEXP(2); }
    llvm::Value * rho() { return getValue(3); }
    genericEq(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericEq create(Builder & b, llvm::Value * lhs, llvm::Value * rhs, SEXP call, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(lhs);
        args_.push_back(rhs);
        args_.push_back(Builder::constantPoolSexp(call));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericNe: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * lhs() { return getValue(0); }
    llvm::Value * rhs() { return getValue(1); }
    SEXP call() { return getValueSEXP(2); }
    llvm::Value * rho() { return getValue(3); }
    genericNe(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericNe create(Builder & b, llvm::Value * lhs, llvm::Value * rhs, SEXP call, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(lhs);
        args_.push_back(rhs);
        args_.push_back(Builder::constantPoolSexp(call));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericLt: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * lhs() { return getValue(0); }
    llvm::Value * rhs() { return getValue(1); }
    SEXP call() { return getValueSEXP(2); }
    llvm::Value * rho() { return getValue(3); }
    genericLt(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericLt create(Builder & b, llvm::Value * lhs, llvm::Value * rhs, SEXP call, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(lhs);
        args_.push_back(rhs);
        args_.push_back(Builder::constantPoolSexp(call));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericLe: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * lhs() { return getValue(0); }
    llvm::Value * rhs() { return getValue(1); }
    SEXP call() { return getValueSEXP(2); }
    llvm::Value * rho() { return getValue(3); }
    genericLe(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericLe create(Builder & b, llvm::Value * lhs, llvm::Value * rhs, SEXP call, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(lhs);
        args_.push_back(rhs);
        args_.push_back(Builder::constantPoolSexp(call));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericGe: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * lhs() { return getValue(0); }
    llvm::Value * rhs() { return getValue(1); }
    SEXP call() { return getValueSEXP(2); }
    llvm::Value * rho() { return getValue(3); }
    genericGe(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericGe create(Builder & b, llvm::Value * lhs, llvm::Value * rhs, SEXP call, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(lhs);
        args_.push_back(rhs);
        args_.push_back(Builder::constantPoolSexp(call));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericGt: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * lhs() { return getValue(0); }
    llvm::Value * rhs() { return getValue(1); }
    SEXP call() { return getValueSEXP(2); }
    llvm::Value * rho() { return getValue(3); }
    genericGt(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericGt create(Builder & b, llvm::Value * lhs, llvm::Value * rhs, SEXP call, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(lhs);
        args_.push_back(rhs);
        args_.push_back(Builder::constantPoolSexp(call));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericBitAnd: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * lhs() { return getValue(0); }
    llvm::Value * rhs() { return getValue(1); }
    SEXP call() { return getValueSEXP(2); }
    llvm::Value * rho() { return getValue(3); }
    genericBitAnd(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericBitAnd create(Builder & b, llvm::Value * lhs, llvm::Value * rhs, SEXP call, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(lhs);
        args_.push_back(rhs);
        args_.push_back(Builder::constantPoolSexp(call));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericBitOr: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * lhs() { return getValue(0); }
    llvm::Value * rhs() { return getValue(1); }
    SEXP call() { return getValueSEXP(2); }
    llvm::Value * rho() { return getValue(3); }
    genericBitOr(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericBitOr create(Builder & b, llvm::Value * lhs, llvm::Value * rhs, SEXP call, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(lhs);
        args_.push_back(rhs);
        args_.push_back(Builder::constantPoolSexp(call));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericNot: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * op() { return getValue(0); }
    SEXP call() { return getValueSEXP(1); }
    llvm::Value * rho() { return getValue(2); }
    genericNot(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericNot create(Builder & b, llvm::Value * op, SEXP call, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(op);
        args_.push_back(Builder::constantPoolSexp(call));
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericGetVarMissOK: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * symbol() { return getValue(0); }
    llvm::Value * rho() { return getValue(1); }
    genericGetVarMissOK(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericGetVarMissOK create(Builder & b, llvm::Value * symbol, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(symbol);
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class genericGetEllipsisValueMissOK: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * symbol() { return getValue(0); }
    llvm::Value * rho() { return getValue(1); }
    genericGetEllipsisValueMissOK(llvm::CallInst * ins): Intrinsic(ins) {}
    static genericGetEllipsisValueMissOK create(Builder & b, llvm::Value * symbol, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(symbol);
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class checkSwitchControl: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * ctrl() { return getValue(0); }
    SEXP call() { return getValueSEXP(1); }
    checkSwitchControl(llvm::CallInst * ins): Intrinsic(ins) {}
    static checkSwitchControl create(Builder & b, llvm::Value * ctrl, SEXP call) {
        std::vector<llvm::Value *> args_;
        args_.push_back(ctrl);
        args_.push_back(Builder::constantPoolSexp(call));
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class switchControlCharacter: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * ctrl() { return getValue(0); }
    SEXP call() { return getValueSEXP(1); }
    SEXP cases() { return getValueSEXP(2); }
    switchControlCharacter(llvm::CallInst * ins): Intrinsic(ins) {}
    static switchControlCharacter create(Builder & b, llvm::Value * ctrl, SEXP call, SEXP cases) {
        std::vector<llvm::Value *> args_;
        args_.push_back(ctrl);
        args_.push_back(Builder::constantPoolSexp(call));
        args_.push_back(Builder::constantPoolSexp(cases));
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class switchControlInteger: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * ctrl() { return getValue(0); }
    int numCases() { return getValueInt(1); }
    switchControlInteger(llvm::CallInst * ins): Intrinsic(ins) {}
    static switchControlInteger create(Builder & b, llvm::Value * ctrl, int numCases) {
        std::vector<llvm::Value *> args_;
        args_.push_back(ctrl);
        args_.push_back(Builder::integer(numCases));
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};

class returnJump: public Intrinsic {
public:
    static llvm::FunctionType * Type;
    static char const * Name;
    llvm::Value * value() { return getValue(0); }
    llvm::Value * rho() { return getValue(1); }
    returnJump(llvm::CallInst * ins): Intrinsic(ins) {}
    static returnJump create(Builder & b, llvm::Value * value, llvm::Value * rho) {
        std::vector<llvm::Value *> args_;
        args_.push_back(value);
        args_.push_back(rho);
        llvm::CallInst * ins = llvm::CallInst::Create(b.intrinsic(Name, Type), args_, "", b);
        b.insertCall(ins);
        return ins;
    }
};
} // namespace ir
} // namespace rjit
#endif // INTRINSICS_H_

